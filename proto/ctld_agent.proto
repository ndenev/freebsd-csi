syntax = "proto3";

package ctld_agent.v1;

enum ExportType {
    EXPORT_TYPE_UNSPECIFIED = 0;
    EXPORT_TYPE_ISCSI = 1;
    EXPORT_TYPE_NVMEOF = 2;
}

// Clone mode determines how volumes are created from snapshots
enum CloneMode {
    // Default: server chooses (currently defaults to LINKED)
    CLONE_MODE_UNSPECIFIED = 0;

    // Instant clone using zfs clone (creates dependency on source snapshot)
    // Fast, space-efficient, but source volume/snapshot cannot be deleted
    // until clone is deleted or promoted
    CLONE_MODE_LINKED = 1;

    // Full copy using zfs send/recv (independent volume)
    // Slow (time proportional to data size), uses full space,
    // but no dependencies - source can be deleted immediately
    CLONE_MODE_COPY = 2;
}

// iSCSI CHAP authentication credentials
// Used for both initiator authentication (forward CHAP) and mutual authentication
message IscsiChapCredentials {
    // Forward CHAP: initiator authenticates to target
    string username = 1;
    string secret = 2;

    // Mutual CHAP (optional): target authenticates to initiator
    // Only used if mutual_username is non-empty
    string mutual_username = 3;
    string mutual_secret = 4;
}

// NVMeoF authentication credentials (FreeBSD 15+)
//
// Note: FreeBSD 15's ctld does not yet support DH-HMAC-CHAP for NVMeoF.
// Currently only host-nqn based access control is implemented.
// The secret/hash_function/dh_group fields are reserved for future use
// when ctld adds DH-HMAC-CHAP support.
message NvmeAuthCredentials {
    // Host NQN for access control (required)
    // Only hosts with matching NQN can connect to the controller
    string host_nqn = 1;

    // Reserved for future DH-HMAC-CHAP support
    string secret = 2;
    string hash_function = 3;
    string dh_group = 4;
}

// Authentication credentials - protocol-specific
// The auth type should match the export_type in the request
message AuthCredentials {
    oneof credentials {
        IscsiChapCredentials iscsi_chap = 1;
        NvmeAuthCredentials nvme_auth = 2;
    }
}

// Content source for creating a volume from existing data
message VolumeContentSource {
    // Source type: either a snapshot or an existing volume
    oneof source {
        // The snapshot to restore from (snapshot ID as returned by CreateSnapshot)
        // Format: "volume_id@snap_name"
        string snapshot_id = 1;

        // The source volume to clone from (volume ID)
        // A temporary snapshot will be created for the clone operation
        // For COPY mode: temp snapshot is deleted after copy completes
        // For LINKED mode: temp snapshot is preserved (clone depends on it)
        string source_volume_id = 3;
    }

    // How to create the volume from the source
    // LINKED: fast but creates dependency (zfs clone)
    // COPY: slow but independent (zfs send/recv)
    CloneMode clone_mode = 2;
}

// Volume represents a ZFS dataset exported via iSCSI or NVMeoF
message Volume {
    string id = 1;
    string name = 2;
    int64 size_bytes = 3;
    string zfs_dataset = 4;
    ExportType export_type = 5;
    string target_name = 6;  // iSCSI IQN or NVMeoF NQN
    int32 lun_id = 7;
    map<string, string> parameters = 8;
}

message CreateVolumeRequest {
    string name = 1;
    int64 size_bytes = 2;
    ExportType export_type = 3;
    map<string, string> parameters = 4;

    // Optional authentication credentials
    // If provided, the target will require authentication
    // Type should match export_type (iscsi_chap for iSCSI, nvme_auth for NVMeoF)
    AuthCredentials auth = 5;

    // Optional: create volume from existing snapshot
    // If provided, volume data is populated from the specified snapshot
    VolumeContentSource content_source = 6;
}

message CreateVolumeResponse {
    Volume volume = 1;
}

message DeleteVolumeRequest {
    string volume_id = 1;
}

message DeleteVolumeResponse {}

message ExpandVolumeRequest {
    string volume_id = 1;
    int64 new_size_bytes = 2;
}

message ExpandVolumeResponse {
    int64 size_bytes = 1;
}

message ListVolumesRequest {
    int32 max_entries = 1;
    string starting_token = 2;
}

message ListVolumesResponse {
    repeated Volume volumes = 1;
    string next_token = 2;
}

message GetVolumeRequest {
    string volume_id = 1;
}

message GetVolumeResponse {
    Volume volume = 1;
}

// Snapshot operations
message Snapshot {
    string id = 1;
    string source_volume_id = 2;
    string name = 3;
    int64 creation_time = 4;
    int64 size_bytes = 5;
}

message CreateSnapshotRequest {
    string source_volume_id = 1;
    string name = 2;
}

message CreateSnapshotResponse {
    Snapshot snapshot = 1;
}

message DeleteSnapshotRequest {
    string snapshot_id = 1;
}

message DeleteSnapshotResponse {}

message ListSnapshotsRequest {
    string source_volume_id = 1;  // optional filter by volume
    int32 max_entries = 2;
    string starting_token = 3;
}

message ListSnapshotsResponse {
    repeated Snapshot snapshots = 1;
    string next_token = 2;
}

message GetSnapshotRequest {
    string snapshot_id = 1;
}

message GetSnapshotResponse {
    Snapshot snapshot = 1;
}

// Capacity information for the storage pool
message GetCapacityRequest {
    // Optional: filter by parameters (e.g., exportType)
    map<string, string> parameters = 1;
}

message GetCapacityResponse {
    // Available capacity in bytes
    int64 available_capacity = 1;
    // Total capacity in bytes
    int64 total_capacity = 2;
    // Used capacity in bytes
    int64 used_capacity = 3;
}

// The storage agent service
service StorageAgent {
    // Volume operations
    rpc CreateVolume(CreateVolumeRequest) returns (CreateVolumeResponse);
    rpc DeleteVolume(DeleteVolumeRequest) returns (DeleteVolumeResponse);
    rpc ExpandVolume(ExpandVolumeRequest) returns (ExpandVolumeResponse);
    rpc ListVolumes(ListVolumesRequest) returns (ListVolumesResponse);
    rpc GetVolume(GetVolumeRequest) returns (GetVolumeResponse);

    // Snapshot operations
    rpc CreateSnapshot(CreateSnapshotRequest) returns (CreateSnapshotResponse);
    rpc DeleteSnapshot(DeleteSnapshotRequest) returns (DeleteSnapshotResponse);
    rpc ListSnapshots(ListSnapshotsRequest) returns (ListSnapshotsResponse);
    rpc GetSnapshot(GetSnapshotRequest) returns (GetSnapshotResponse);

    // Capacity information
    rpc GetCapacity(GetCapacityRequest) returns (GetCapacityResponse);
}
